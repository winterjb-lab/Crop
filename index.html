<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Background Cropper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Favicon (place favicon.png next to this HTML) -->
  <link rel="icon" href="favicon.png" type="image/png">

  <style>
    :root{
      --bg: #f5f5f7;
      --card: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --border: rgba(17,24,39,.10);
      --shadow: 0 10px 30px rgba(17,24,39,.08);
      --radius: 16px;

      --control-h: 44px;

      --preview-w: 960px;
      --preview-h: 360px;
    }

    * { box-sizing: border-box; }
    body{
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .page{
      max-width: 1120px;
      margin: 0 auto;
      padding: 28px 18px 42px;
    }

    .header{ margin-bottom: 14px; }
    .title{
      margin: 0;
      font-size: 20px;
      letter-spacing: -0.01em;
    }
    .subtitle{
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
      max-width: 70ch;
    }

    .card{
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .controls{
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: flex-end;
    }

    .field{
      display: grid;
      gap: 6px;
      flex: 1 1 520px;
      min-width: 320px;
    }

    .label{
      font-size: 12px;
      color: var(--muted);
    }

    select{
      width: 100%;
      height: var(--control-h);
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 12px;
      padding: 0 12px;
      font-size: 14px;
      outline: none;
    }
    select:focus{ border-color: rgba(17,24,39,.22); }

    .actions{
      display: inline-flex;
      gap: 12px;
      align-items: center;
      flex: 0 0 auto;
    }

    .btn{
      height: var(--control-h);
      border: 1px solid var(--border);
      background: rgba(255,255,255,.55);
      border-radius: 12px;
      padding: 0 14px;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
    }
    .btn:disabled{ opacity: .55; cursor: not-allowed; }

    .btn.primary{
      background: #111827;
      color: #fff;
      border-color: rgba(17,24,39,.35);
    }

    .toggle{
      height: var(--control-h);
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 0 14px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fff;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    .toggle input{
      width: 18px;
      height: 18px;
      margin: 0;
      transform: translateY(1px);
    }

    #status{
      font-size: 12px;
      color: var(--muted);
      margin-top: 10px;
      min-height: 16px;
    }

    .quality-warning{
      display: none;
      font-size: 12px;
      color: #b00020;
      font-weight: 600;
      margin-top: 8px;
      line-height: 1.35;
    }

    /* ===== Crop preview window ===== */
    .previewWrap{
      margin-top: 12px;
      padding: 14px;
    }

    /* Center the preview inside the card */
    .cropSizer{
      width: min(var(--preview-w), 100%);
      margin: 0 auto;
    }

    #crop{
      position: relative;
      width: 100%;
      height: var(--preview-h);
      overflow: hidden;
      border-radius: 18px;
      border: 1px solid var(--border);
      background: #111827;
      touch-action: none;
      user-select: none;
    }

    /* Hide images until loaded to avoid broken-image icons */
    #img, #overlayGuides{
      display: none;
    }

    #img{
      position: absolute; top: 0; left: 0;
      transform-origin: top left;
      will-change: transform;
      pointer-events: none;
    }

    #crop::after{
      content: "";
      position: absolute;
      inset: 0;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 18px;
      pointer-events: none;
    }

    #overlayGuides{
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      pointer-events: none;
      border-radius: 18px;
      z-index: 3;
      opacity: 0.88;
    }

    .footerNote{
      margin-top: 10px;
      text-align: center;
      color: var(--muted);
      font-size: 12px;
    }

    @media (max-width: 860px){
      .actions{ width: 100%; justify-content: flex-start; }
    }
  </style>
</head>

<body>
  <div class="page">
    <div class="header">
      <h1 class="title">Background Cropper</h1>
      <p class="subtitle">Upload an image, drag to reposition, scroll to zoom, and click export.</p>
    </div>

    <div class="card">
      <div class="controls">
        <div class="field">
          <div class="label">Preset</div>
          <select id="preset" aria-label="Preset">
            <option value="rotator">Fire TV Feature Rotator — 1920×720 (≤450 KB JPG)</option>
            <option value="screensaver">Fire TV Screen Saver — 1920×1080 (≤450 KB JPG)</option>
            <option value="prime_rotator_3840">Prime Video Feature Rotator Connected TV and desktop — 3840×1440 (≤10 MB JPG)</option>
            <option value="prime_mobile_1936">Prime Video Feature Rotator Mobile and tablet — 1936×1089 (≤10 MB JPG)</option>
          </select>
        </div>

        <div class="actions">
          <input id="file" type="file" accept="image/*" hidden />
          <label class="btn" for="file">Upload Image</label>

          <label class="toggle" for="toggleGuides">
            <input type="checkbox" id="toggleGuides" checked />
            Show guidelines
          </label>

          <button id="export" class="btn primary" disabled>Export</button>
        </div>
      </div>

      <div id="qualityWarning" class="quality-warning"></div>
      <div id="status" aria-live="polite"></div>
    </div>

    <div class="card previewWrap">
      <div class="cropSizer">
        <div id="crop" aria-label="Image crop area (drag to pan, scroll to zoom)" role="application" tabindex="0">
          <img id="img" alt="" />
          <img id="overlayGuides" alt="" />
        </div>
      </div>
      <div class="footerNote">Tip: Zoom-out is limited to prevent black borders.</div>
    </div>
  </div>

  <script>
    /* ===== Presets ===== */
    const PRESETS = {
      rotator: {
        name: "Fire TV Feature Rotator",
        w: 1920, h: 720,
        minInputW: 1920, minInputH: 720,
        maxBytes: 450 * 1024,
        previewW: 960,
        exportMime: "image/jpeg",
        exportExt: "jpg",
        exportQualityCapable: true,
        guideOverlay: "rotator-overlay.png"
      },
      screensaver: {
        name: "Fire TV Screen Saver",
        w: 1920, h: 1080,
        minInputW: 1920, minInputH: 1080,
        maxBytes: 450 * 1024,
        previewW: 768, // 20% smaller
        exportMime: "image/jpeg",
        exportExt: "jpg",
        exportQualityCapable: true,
        guideOverlay: "screensaver-overlay.png"
      },
      prime_rotator_3840: {
        name: "Prime Video Feature Rotator Connected TV and desktop",
        w: 3840, h: 1440,
        minInputW: 3840, minInputH: 1440,
        maxBytes: 10 * 1024 * 1024,
        previewW: 960,
        exportMime: "image/jpeg",
        exportExt: "jpg",
        exportQualityCapable: true,
        guideOverlay: "Prime Video Feature Rotator - 3840x1440.png"
      },
      /* UPDATED: Mobile & tablet now exports JPG (not PNG) */
      prime_mobile_1936: {
        name: "Prime Video Feature Rotator Mobile and tablet",
        w: 1936, h: 1089,
        minInputW: 1936, minInputH: 1089,
        maxBytes: 10 * 1024 * 1024,
        previewW: 768, // ~20% smaller
        exportMime: "image/jpeg",
        exportExt: "jpg",
        exportQualityCapable: true,
        // As requested (no extension). Will auto-try ".png" if needed.
        guideOverlay: "Prime Video Feature Rotator - 1936x1089"
      },
    };

    const presetSel = document.getElementById('preset');
    const fileInput = document.getElementById('file');
    const exportBtn = document.getElementById('export');
    const statusEl  = document.getElementById('status');
    const crop      = document.getElementById('crop');
    const img       = document.getElementById('img');
    const overlayGuides = document.getElementById('overlayGuides');
    const toggleGuides   = document.getElementById('toggleGuides');
    const qualityWarning = document.getElementById('qualityWarning');

    // State
    let current = PRESETS.rotator;
    let imgUrl = null;
    let naturalW = 0, naturalH = 0;
    let scale = 1;
    let minScale = 1; // prevents zoom-out beyond cover
    let offsetX = 0, offsetY = 0;
    let originalBaseName = "image";

    function setStatus(msg){ statusEl.textContent = msg || ""; }

    function sanitizeFilePart(s) {
      return (s || "")
        .trim()
        .replace(/\s+/g, "-")
        .replace(/[^a-zA-Z0-9._-]+/g, "");
    }

    function getBaseName(filename) {
      if (!filename) return "image";
      const lastSlash = Math.max(filename.lastIndexOf("/"), filename.lastIndexOf("\\"));
      const justName = lastSlash >= 0 ? filename.slice(lastSlash + 1) : filename;
      const lastDot = justName.lastIndexOf(".");
      const base = lastDot > 0 ? justName.slice(0, lastDot) : justName;
      return base || "image";
    }

    function presetSlugFromHumanName() {
      return sanitizeFilePart(current.name.toLowerCase().replace(/\s+/g, "-"));
    }

    function resizePreviewForPreset() {
      const pw = current.previewW;
      const ph = Math.round(pw * (current.h / current.w));
      document.documentElement.style.setProperty('--preview-w', pw + 'px');
      document.documentElement.style.setProperty('--preview-h', ph + 'px');
    }

    function cropRect() { return { w: crop.clientWidth, h: crop.clientHeight }; }

    function computeMinScale() {
      const { w: cropW, h: cropH } = cropRect();
      minScale = Math.max(cropW / naturalW, cropH / naturalH);
    }

    function applyTransform() {
      img.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
    }

    function fitToCover() {
      if (!naturalW) return;
      computeMinScale();
      scale = minScale;

      const { w: cropW, h: cropH } = cropRect();
      const displayW = naturalW * scale;
      const displayH = naturalH * scale;

      offsetX = (cropW - displayW) / 2;
      offsetY = (cropH - displayH) / 2;

      applyTransform();
    }

    function constrain(offX, offY, scl = scale) {
      const { w: cropW, h: cropH } = cropRect();
      const displayW = naturalW * scl;
      const displayH = naturalH * scl;

      if (displayW <= cropW) offX = (cropW - displayW) / 2;
      else offX = Math.min(0, Math.max(cropW - displayW, offX));

      if (displayH <= cropH) offY = (cropH - displayH) / 2;
      else offY = Math.min(0, Math.max(cropH - displayH, offY));

      return [offX, offY];
    }

    function updateQualityWarning() {
      if (!naturalW) {
        qualityWarning.style.display = "none";
        qualityWarning.textContent = "";
        return;
      }
      const minW = current.minInputW || current.w;
      const minH = current.minInputH || current.h;

      const belowSpec = (naturalW < minW) || (naturalH < minH);
      if (belowSpec) {
        qualityWarning.textContent =
          `⚠️ Image may be lower quality: Required spec (${minW}×${minH}px) your image is smaller (${naturalW}×${naturalH}px).`;
        qualityWarning.style.display = "block";
      } else {
        qualityWarning.style.display = "none";
        qualityWarning.textContent = "";
      }
    }

    // Overlay load: hidden until loaded; if no extension, try ".png"
    function setOverlayWithFallback(path) {
      overlayGuides.style.display = "none";
      overlayGuides.onerror = null;
      overlayGuides.onload = null;

      if (!path || !toggleGuides.checked) return;

      overlayGuides.onload = () => {
        overlayGuides.style.display = toggleGuides.checked ? "block" : "none";
      };

      overlayGuides.src = path;

      overlayGuides.onerror = () => {
        if (/\.[a-z0-9]+$/i.test(path)) return;
        overlayGuides.onerror = null;
        overlayGuides.src = path + ".png";
      };
    }

    function applyPresetVisuals() {
      resizePreviewForPreset();
      setOverlayWithFallback(current.guideOverlay || "");
      exportBtn.textContent = current.exportExt.toUpperCase() === "PNG" ? "Export PNG" : "Export JPG";
    }

    presetSel.addEventListener('change', () => {
      current = PRESETS[presetSel.value];
      applyPresetVisuals();
      if (naturalW) {
        fitToCover();
        updateQualityWarning();
      }
    });

    toggleGuides.addEventListener('change', () => {
      setOverlayWithFallback(current.guideOverlay || "");
    });

    /* ===== File load ===== */
    fileInput.addEventListener('change', e => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      originalBaseName = sanitizeFilePart(getBaseName(file.name));

      if (imgUrl) URL.revokeObjectURL(imgUrl);
      imgUrl = URL.createObjectURL(file);

      // Hide until loaded (prevents broken icon)
      img.style.display = "none";
      img.src = imgUrl;

      setStatus("Loading…");
      exportBtn.disabled = true;

      const probe = new Image();
      probe.onload = () => {
        naturalW = probe.naturalWidth;
        naturalH = probe.naturalHeight;

        applyPresetVisuals();

        img.style.display = "block";
        fitToCover();

        exportBtn.disabled = false;
        setStatus(`Image loaded: ${naturalW}×${naturalH}px`);
        updateQualityWarning();
      };
      probe.onerror = () => setStatus("Could not load that image.");
      probe.src = imgUrl;
    });

    /* ===== Dragging / Zooming ===== */
    let dragging = false, startX = 0, startY = 0, startOffX = 0, startOffY = 0;

    function onPointerDown(x, y){
      if (!naturalW) return;
      dragging = true;
      startX = x; startY = y;
      startOffX = offsetX; startOffY = offsetY;
    }
    function onPointerMove(x, y){
      if (!dragging) return;
      const dx = x - startX, dy = y - startY;
      [offsetX, offsetY] = constrain(startOffX + dx, startOffY + dy);
      applyTransform();
    }
    function endDrag(){ dragging = false; }

    crop.addEventListener('mousedown', e => { e.preventDefault(); onPointerDown(e.clientX, e.clientY); });
    window.addEventListener('mousemove', e => onPointerMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', endDrag);

    crop.addEventListener('touchstart', e => { const t = e.touches[0]; if (!t) return; onPointerDown(t.clientX, t.clientY); }, { passive: false });
    crop.addEventListener('touchmove',  e => { const t = e.touches[0]; if (!t) return; e.preventDefault(); onPointerMove(t.clientX, t.clientY); }, { passive: false });
    crop.addEventListener('touchend', endDrag);

    crop.addEventListener('wheel', e => {
      if (!naturalW) return;
      e.preventDefault();

      const next = Math.min(8, Math.max(minScale, scale * (1 - e.deltaY * 0.0015)));
      if (next === scale) return;

      const rect = crop.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const relX = mouseX - offsetX;
      const relY = mouseY - offsetY;

      const k = next / scale;

      let nx = offsetX - relX * (k - 1);
      let ny = offsetY - relY * (k - 1);

      [nx, ny] = constrain(nx, ny, next);

      scale = next;
      offsetX = nx;
      offsetY = ny;
      applyTransform();
    }, { passive: false });

    /* ===== Export ===== */
    async function canvasToBlob(canvas, mime, quality) {
      return await new Promise(res => canvas.toBlob(b => res(b), mime, quality));
    }

    async function exportAsset() {
      if (!naturalW) return;

      setStatus("Exporting…");
      exportBtn.disabled = true;

      const { w: cropW, h: cropH } = cropRect();

      const sx = Math.max(0, (-offsetX) / scale);
      const sy = Math.max(0, (-offsetY) / scale);
      const sw = Math.min(naturalW, cropW / scale);
      const sh = Math.min(naturalH, cropH / scale);

      const canvas = document.createElement('canvas');
      canvas.width = current.w;
      canvas.height = current.h;

      const ctx = canvas.getContext('2d', { alpha: false });
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      ctx.drawImage(img, sx, sy, sw, sh, 0, 0, current.w, current.h);

      let blob = null;

      if (current.exportQualityCapable) {
        let q = 0.92;
        for (let i = 0; i < 12; i++) {
          blob = await canvasToBlob(canvas, current.exportMime, q);
          if (!blob) break;
          if (!current.maxBytes || blob.size <= current.maxBytes) break;
          q -= 0.07;
          if (q < 0.35) break;
        }
      } else {
        blob = await canvasToBlob(canvas, current.exportMime);
      }

      if (!blob) {
        setStatus("Export failed.");
        exportBtn.disabled = false;
        return;
      }

      const filename = `${originalBaseName}_${presetSlugFromHumanName()}_BG.${current.exportExt}`;

      const kb = Math.round(blob.size / 1024);
      const mb = (blob.size / (1024 * 1024)).toFixed(2);
      if (current.maxBytes && blob.size > current.maxBytes) {
        setStatus(`Exported ${current.w}×${current.h}px → ${mb} MB (over limit).`);
      } else {
        setStatus(`Exported ${current.w}×${current.h}px → ${kb} KB`);
      }

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);

      exportBtn.disabled = false;
      updateQualityWarning();
    }

    exportBtn.addEventListener('click', exportAsset);

    /* ===== Init ===== */
    function init() {
      resizePreviewForPreset();
      applyPresetVisuals();
      updateQualityWarning();
    }
    init();

    window.addEventListener('resize', () => {
      if (!naturalW) return;
      computeMinScale();
      if (scale < minScale) scale = minScale;
      [offsetX, offsetY] = constrain(offsetX, offsetY, scale);
      applyTransform();
      updateQualityWarning();
    });
  </script>
</body>
</html>
