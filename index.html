<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Background Cropper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Favicon (place favicon.png next to this HTML) -->
  <link rel="icon" href="favicon.png" type="image/png">

  <style>
    :root{
      --bg: #f5f5f7;
      --card: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --border: rgba(17,24,39,.10);
      --shadow: 0 10px 30px rgba(17,24,39,.08);
      --radius: 16px;

      --control-h: 44px;

      --preview-w: 960px;
      --preview-h: 360px;
    }

    * { box-sizing: border-box; }
    body{
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .page{
      max-width: 1120px;
      margin: 0 auto;
      padding: 28px 18px 42px;
    }

    .header{ margin-bottom: 14px; }
    .title{
      margin: 0;
      font-size: 20px;
      letter-spacing: -0.01em;
    }
    .subtitle{
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
      max-width: 70ch;
    }

    .card{
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }

    .controls{
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: flex-end;
    }

    .field{
      display: grid;
      gap: 6px;
      flex: 1 1 520px;
      min-width: 320px;
    }

    .label{
      font-size: 12px;
      color: var(--muted);
    }

    select, input[type="text"]{
      width: 100%;
      height: var(--control-h);
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 12px;
      padding: 0 12px;
      font-size: 14px;
      outline: none;
    }
    select:focus, input[type="text"]:focus{ border-color: rgba(17,24,39,.22); }

    .actions{
      display: inline-flex;
      gap: 12px;
      align-items: center;
      flex: 0 0 auto;
    }

    .btn{
      height: var(--control-h);
      border: 1px solid var(--border);
      background: rgba(255,255,255,.55);
      border-radius: 12px;
      padding: 0 14px;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
    }
    .btn:disabled{ opacity: .55; cursor: not-allowed; }

    .btn.primary{
      background: #111827;
      color: #fff;
      border-color: rgba(17,24,39,.35);
    }

    .toggle{
      height: var(--control-h);
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 0 14px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fff;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    .toggle input{
      width: 18px;
      height: 18px;
      margin: 0;
      transform: translateY(1px);
    }

    #status{
      font-size: 12px;
      color: var(--muted);
      margin-top: 10px;
      min-height: 16px;
    }

    .quality-warning{
      display: none;
      font-size: 12px;
      color: #b00020;
      font-weight: 600;
      margin-top: 8px;
      line-height: 1.35;
    }

    .firetvControls{
      display: none; /* shown only for Fire TV presets */
      margin-top: 12px;
      gap: 12px;
      flex-wrap: wrap;
      align-items: flex-end;
    }
    .firetvControls .field{ flex: 1 1 260px; min-width: 240px; }
    .firetvControls .field.small{ flex: 0 0 240px; }
    .firetvControls .toggle{ background: #fff; }

    /* ===== Crop preview window ===== */
    .previewWrap{
      margin-top: 12px;
      padding: 14px;
    }

    .cropSizer{
      width: min(var(--preview-w), 100%);
      margin: 0 auto;
    }

    #crop{
      position: relative;
      width: 100%;
      height: var(--preview-h);
      overflow: hidden;
      border-radius: 18px;
      border: 1px solid var(--border);
      background: #111827;
      touch-action: none;
      user-select: none;
    }

    #img, #overlayGuides, #badgePreview, #subTextPreview{
      display: none; /* avoid broken icons / only show when active */
    }

    #img{
      position: absolute; top: 0; left: 0;
      transform-origin: top left;
      will-change: transform;
      pointer-events: none;
    }

    #crop::after{
      content: "";
      position: absolute;
      inset: 0;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 18px;
      pointer-events: none;
    }

    #overlayGuides{
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      pointer-events: none;
      border-radius: 18px;
      z-index: 3;
      opacity: 0.88;
    }

    /* Rating badge preview (exact position) */
    #badgePreview{
      position: absolute;
      z-index: 4;
      pointer-events: none;
      image-rendering: auto;
    }

    /* Subscription text preview (fixed safe area) */
    #subTextPreview{
      position: absolute;
      z-index: 4;
      pointer-events: none;
      color: rgba(255,255,255,0.95);
      font-weight: 600;
      text-shadow: 0 2px 10px rgba(0,0,0,0.45);
      white-space: normal;
      line-height: 1.1;
    }

    .footerNote{
      margin-top: 10px;
      text-align: center;
      color: var(--muted);
      font-size: 12px;
    }

    @media (max-width: 860px){
      .actions{ width: 100%; justify-content: flex-start; }
    }
  </style>
</head>

<body>
  <div class="page">
    <div class="header">
      <h1 class="title">Background Cropper</h1>
      <p class="subtitle">Upload an image, drag to reposition, scroll to zoom, and click export.</p>
    </div>

    <div class="card">
      <div class="controls">
        <div class="field">
          <div class="label">Preset</div>
          <select id="preset" aria-label="Preset">
            <option value="rotator">Fire TV Feature Rotator — 1920×720 (≤450 KB JPG)</option>
            <option value="screensaver">Fire TV Screen Saver — 1920×1080 (≤450 KB JPG)</option>
            <option value="prime_rotator_3840">Prime Video Feature Rotator Connected TV and desktop — 3840×1440 (≤10 MB JPG)</option>
            <option value="prime_mobile_1936">Prime Video Feature Rotator Mobile and tablet — 1936×1089 (≤10 MB JPG)</option>
          </select>
        </div>

        <div class="actions">
          <input id="file" type="file" accept="image/*" hidden />
          <label class="btn" for="file">Upload Image</label>

          <label class="toggle" for="toggleGuides">
            <input type="checkbox" id="toggleGuides" checked />
            Show guidelines
          </label>

          <button id="export" class="btn primary" disabled>Export</button>
        </div>
      </div>

      <!-- Fire TV-only controls -->
      <div id="firetvControls" class="firetvControls" style="display:none;">
        <div class="field small">
          <div class="label">Age rating (Fire TV only)</div>
          <select id="ratingSelect" aria-label="Age rating">
            <option value="none">None</option>
            <option value="U">U</option>
            <option value="PG">PG</option>
            <option value="12">12</option>
            <option value="12A">12A</option>
            <option value="15">15</option>
            <option value="18">18</option>
          </select>
        </div>

        <label class="toggle" for="toggleSubText">
          <input type="checkbox" id="toggleSubText" />
          Subscription text
        </label>

        <div class="field" style="min-width: 320px;">
          <div class="label">Text (Fire TV only)</div>
          <input id="subText" type="text" placeholder="e.g., Subscription required" />
        </div>
      </div>

      <div id="qualityWarning" class="quality-warning"></div>
      <div id="status" aria-live="polite"></div>
    </div>

    <div class="card previewWrap">
      <div class="cropSizer">
        <div id="crop" aria-label="Image crop area (drag to pan, scroll to zoom)" role="application" tabindex="0">
          <img id="img" alt="" />
          <img id="overlayGuides" alt="" />
          <img id="badgePreview" alt="" />
          <div id="subTextPreview"></div>
        </div>
      </div>
      <div class="footerNote">Tip: Zoom-out is limited to prevent black borders.</div>
    </div>
  </div>

  <script>
    /* ===== Rating badge assets ===== */
    const RATING_PNG = {
      none: "",
      U: "U.png",
      PG: "PG.png",
      "12": "12.png",
      "12A": "12A.png",
      "15": "15.png",
      "18": "18.png",
    };

    /* ===== Presets ===== */
    const PRESETS = {
      rotator: {
        name: "Fire TV Feature Rotator",
        w: 1920, h: 720,
        minInputW: 1920, minInputH: 720,
        maxBytes: 450 * 1024,
        previewW: 960,
        exportMime: "image/jpeg",
        exportExt: "jpg",
        exportQualityCapable: true,
        guideOverlay: "rotator-overlay.png",

        // Fire TV rating placement (provided by you via PS Transform panel)
        firetv: {
          rating: { x: 1775, y: 578, w: 40, h: 36 },
          // Text placed to the LEFT of badge, vertically centered to badge
          subText: { maxW: 520, gap: 12, fontPx: 20, maxLines: 2 }
        }
      },
      screensaver: {
        name: "Fire TV Screen Saver",
        w: 1920, h: 1080,
        minInputW: 1920, minInputH: 1080,
        maxBytes: 450 * 1024,
        previewW: 768, // 20% smaller
        exportMime: "image/jpeg",
        exportExt: "jpg",
        exportQualityCapable: true,
        guideOverlay: "screensaver-overlay.png",

        // Derived from Rotator margins: right=105, bottom=106, same badge size
        firetv: {
          rating: { x: 1775, y: 938, w: 40, h: 36 }, // 1080 - 106 - 36 = 938
          subText: { maxW: 640, gap: 12, fontPx: 22, maxLines: 2 }
        }
      },
      prime_rotator_3840: {
        name: "Prime Video Feature Rotator Connected TV and desktop",
        w: 3840, h: 1440,
        minInputW: 3840, minInputH: 1440,
        maxBytes: 10 * 1024 * 1024,
        previewW: 960,
        exportMime: "image/jpeg",
        exportExt: "jpg",
        exportQualityCapable: true,
        guideOverlay: "Prime Video Feature Rotator - 3840x1440.png"
      },
      prime_mobile_1936: {
        name: "Prime Video Feature Rotator Mobile and tablet",
        w: 1936, h: 1089,
        minInputW: 1936, minInputH: 1089,
        maxBytes: 10 * 1024 * 1024,
        previewW: 768,
        exportMime: "image/jpeg",
        exportExt: "jpg",
        exportQualityCapable: true,
        guideOverlay: "Prime Video Feature Rotator - 1936x1089.png"
      },
    };

    const presetSel = document.getElementById('preset');
    const fileInput = document.getElementById('file');
    const exportBtn = document.getElementById('export');
    const statusEl  = document.getElementById('status');
    const crop      = document.getElementById('crop');
    const img       = document.getElementById('img');
    const overlayGuides = document.getElementById('overlayGuides');
    const toggleGuides   = document.getElementById('toggleGuides');
    const qualityWarning = document.getElementById('qualityWarning');

    const firetvControls = document.getElementById('firetvControls');
    const ratingSelect   = document.getElementById('ratingSelect');
    const toggleSubText  = document.getElementById('toggleSubText');
    const subTextInput   = document.getElementById('subText');
    const badgePreview   = document.getElementById('badgePreview');
    const subTextPreview = document.getElementById('subTextPreview');

    // State
    let current = PRESETS.rotator;
    let imgUrl = null;
    let naturalW = 0, naturalH = 0;
    let scale = 1;
    let minScale = 1;
    let offsetX = 0, offsetY = 0;
    let originalBaseName = "image";

    // Rating state
    let ratingValue = "none";
    const ratingImgCache = {}; // key -> HTMLImageElement

    function setStatus(msg){ statusEl.textContent = msg || ""; }

    function sanitizeFilePart(s) {
      return (s || "")
        .trim()
        .replace(/\s+/g, "-")
        .replace(/[^a-zA-Z0-9._-]+/g, "");
    }

    function getBaseName(filename) {
      if (!filename) return "image";
      const lastSlash = Math.max(filename.lastIndexOf("/"), filename.lastIndexOf("\\"));
      const justName = lastSlash >= 0 ? filename.slice(lastSlash + 1) : filename;
      const lastDot = justName.lastIndexOf(".");
      const base = lastDot > 0 ? justName.slice(0, lastDot) : justName;
      return base || "image";
    }

    function presetSlugFromHumanName() {
      return sanitizeFilePart(current.name.toLowerCase().replace(/\s+/g, "-"));
    }

    function resizePreviewForPreset() {
      const pw = current.previewW;
      const ph = Math.round(pw * (current.h / current.w));
      document.documentElement.style.setProperty('--preview-w', pw + 'px');
      document.documentElement.style.setProperty('--preview-h', ph + 'px');
    }

    function cropRect() { return { w: crop.clientWidth, h: crop.clientHeight }; }

    function computeMinScale() {
      const { w: cropW, h: cropH } = cropRect();
      minScale = Math.max(cropW / naturalW, cropH / naturalH);
    }

    function applyTransform() {
      img.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
    }

    function fitToCover() {
      if (!naturalW) return;
      computeMinScale();
      scale = minScale;

      const { w: cropW, h: cropH } = cropRect();
      const displayW = naturalW * scale;
      const displayH = naturalH * scale;

      offsetX = (cropW - displayW) / 2;
      offsetY = (cropH - displayH) / 2;

      applyTransform();
    }

    function constrain(offX, offY, scl = scale) {
      const { w: cropW, h: cropH } = cropRect();
      const displayW = naturalW * scl;
      const displayH = naturalH * scl;

      if (displayW <= cropW) offX = (cropW - displayW) / 2;
      else offX = Math.min(0, Math.max(cropW - displayW, offX));

      if (displayH <= cropH) offY = (cropH - displayH) / 2;
      else offY = Math.min(0, Math.max(cropH - displayH, offY));

      return [offX, offY];
    }

    function updateQualityWarning() {
      if (!naturalW) {
        qualityWarning.style.display = "none";
        qualityWarning.textContent = "";
        return;
      }
      const minW = current.minInputW || current.w;
      const minH = current.minInputH || current.h;

      const belowSpec = (naturalW < minW) || (naturalH < minH);
      if (belowSpec) {
        qualityWarning.textContent =
          `⚠️ Image may be lower quality: Required spec (${minW}×${minH}px) your image is smaller (${naturalW}×${naturalH}px).`;
        qualityWarning.style.display = "block";
      } else {
        qualityWarning.style.display = "none";
        qualityWarning.textContent = "";
      }
    }

    function setOverlay(path) {
      overlayGuides.style.display = "none";
      overlayGuides.onerror = null;
      overlayGuides.onload = null;

      if (!path || !toggleGuides.checked) return;

      overlayGuides.onload = () => {
        overlayGuides.style.display = toggleGuides.checked ? "block" : "none";
      };
      overlayGuides.src = path;
    }

    function isFireTvPreset() {
      return !!current.firetv;
    }

    function updateFireTvControlsVisibility() {
      const show = isFireTvPreset();
      firetvControls.style.display = show ? "flex" : "none";

      if (!show) {
        // hide previews too
        badgePreview.style.display = "none";
        subTextPreview.style.display = "none";
      } else {
        updateBadgePreview();
        updateSubTextPreview();
      }
    }

    function ensureRatingImageLoaded(value) {
      const src = RATING_PNG[value] || "";
      if (!src) return null;

      if (ratingImgCache[value]) return ratingImgCache[value];

      const im = new Image();
      im.onload = () => {
        // refresh preview placement when loaded
        updateBadgePreview();
      };
      im.src = src;
      ratingImgCache[value] = im;
      return im;
    }

    function getPreviewScale() {
      // crop element width corresponds to preview width
      const { w: cropW } = cropRect();
      return cropW / current.w;
    }

    function updateBadgePreview() {
      if (!isFireTvPreset()) return;
      const cfg = current.firetv.rating;
      const src = RATING_PNG[ratingValue] || "";

      if (!src || ratingValue === "none") {
        badgePreview.style.display = "none";
        badgePreview.src = "";
        return;
      }

      ensureRatingImageLoaded(ratingValue);

      const s = getPreviewScale();
      badgePreview.src = src;

      badgePreview.style.width  = (cfg.w * s) + "px";
      badgePreview.style.height = (cfg.h * s) + "px";
      badgePreview.style.left   = (cfg.x * s) + "px";
      badgePreview.style.top    = (cfg.y * s) + "px";
      badgePreview.style.display = "block";
    }

    function wrapText(ctx, text, maxWidth) {
      const words = (text || "").trim().split(/\s+/).filter(Boolean);
      const lines = [];
      let line = "";

      for (const w of words) {
        const test = line ? (line + " " + w) : w;
        if (ctx.measureText(test).width <= maxWidth) {
          line = test;
        } else {
          if (line) lines.push(line);
          line = w;
        }
      }
      if (line) lines.push(line);
      return lines;
    }

    function updateSubTextPreview() {
      if (!isFireTvPreset()) return;

      const enabled = toggleSubText.checked && (subTextInput.value || "").trim().length > 0;
      if (!enabled) {
        subTextPreview.style.display = "none";
        subTextPreview.textContent = "";
        return;
      }

      const cfgR = current.firetv.rating;
      const cfgT = current.firetv.subText;

      const s = getPreviewScale();
      const fontPx = Math.max(10, Math.round(cfgT.fontPx * s));

      // fixed box to the LEFT of badge
      const boxW = Math.round(cfgT.maxW * s);
      const gap  = Math.round(cfgT.gap * s);

      const badgeLeft = cfgR.x * s;
      const badgeTop  = cfgR.y * s;
      const badgeH    = cfgR.h * s;

      const boxLeft = Math.max(0, Math.round(badgeLeft - gap - boxW));
      const boxTop  = Math.round(badgeTop + (badgeH/2) - (fontPx * 0.55)); // optical centering

      subTextPreview.style.left = boxLeft + "px";
      subTextPreview.style.top  = boxTop + "px";
      subTextPreview.style.width = boxW + "px";
      subTextPreview.style.fontSize = fontPx + "px";
      subTextPreview.textContent = subTextInput.value.trim();
      subTextPreview.style.display = "block";
    }

    function applyPresetVisuals() {
      resizePreviewForPreset();
      setOverlay(current.guideOverlay || "");
      exportBtn.textContent = "Export JPG";
      updateFireTvControlsVisibility();
    }

    presetSel.addEventListener('change', () => {
      current = PRESETS[presetSel.value];
      applyPresetVisuals();
      if (naturalW) {
        fitToCover();
        updateQualityWarning();
      }
    });

    toggleGuides.addEventListener('change', () => {
      setOverlay(current.guideOverlay || "");
    });

    ratingSelect.addEventListener('change', () => {
      ratingValue = ratingSelect.value;
      updateBadgePreview();
    });

    toggleSubText.addEventListener('change', updateSubTextPreview);
    subTextInput.addEventListener('input', updateSubTextPreview);

    /* ===== File load ===== */
    fileInput.addEventListener('change', e => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      originalBaseName = sanitizeFilePart(getBaseName(file.name));

      if (imgUrl) URL.revokeObjectURL(imgUrl);
      imgUrl = URL.createObjectURL(file);

      img.style.display = "none";
      img.src = imgUrl;

      setStatus("Loading…");
      exportBtn.disabled = true;

      const probe = new Image();
      probe.onload = () => {
        naturalW = probe.naturalWidth;
        naturalH = probe.naturalHeight;

        applyPresetVisuals();

        img.style.display = "block";
        fitToCover();

        exportBtn.disabled = false;
        setStatus(`Image loaded: ${naturalW}×${naturalH}px`);
        updateQualityWarning();

        // refresh overlay previews
        updateBadgePreview();
        updateSubTextPreview();
      };
      probe.onerror = () => setStatus("Could not load that image.");
      probe.src = imgUrl;
    });

    /* ===== Dragging / Zooming ===== */
    let dragging = false, startX = 0, startY = 0, startOffX = 0, startOffY = 0;

    function onPointerDown(x, y){
      if (!naturalW) return;
      dragging = true;
      startX = x; startY = y;
      startOffX = offsetX; startOffY = offsetY;
    }
    function onPointerMove(x, y){
      if (!dragging) return;
      const dx = x - startX, dy = y - startY;
      [offsetX, offsetY] = constrain(startOffX + dx, startOffY + dy);
      applyTransform();
    }
    function endDrag(){ dragging = false; }

    crop.addEventListener('mousedown', e => { e.preventDefault(); onPointerDown(e.clientX, e.clientY); });
    window.addEventListener('mousemove', e => onPointerMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', endDrag);

    crop.addEventListener('touchstart', e => { const t = e.touches[0]; if (!t) return; onPointerDown(t.clientX, t.clientY); }, { passive: false });
    crop.addEventListener('touchmove',  e => { const t = e.touches[0]; if (!t) return; e.preventDefault(); onPointerMove(t.clientX, t.clientY); }, { passive: false });
    crop.addEventListener('touchend', endDrag);

    crop.addEventListener('wheel', e => {
      if (!naturalW) return;
      e.preventDefault();

      const next = Math.min(8, Math.max(minScale, scale * (1 - e.deltaY * 0.0015)));
      if (next === scale) return;

      const rect = crop.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const relX = mouseX - offsetX;
      const relY = mouseY - offsetY;

      const k = next / scale;

      let nx = offsetX - relX * (k - 1);
      let ny = offsetY - relY * (k - 1);

      [nx, ny] = constrain(nx, ny, next);

      scale = next;
      offsetX = nx;
      offsetY = ny;
      applyTransform();
    }, { passive: false });

    /* ===== Export ===== */
    async function canvasToBlob(canvas, mime, quality) {
      return await new Promise(res => canvas.toBlob(b => res(b), mime, quality));
    }

    async function exportAsset() {
      if (!naturalW) return;

      setStatus("Exporting…");
      exportBtn.disabled = true;

      const { w: cropW, h: cropH } = { w: crop.clientWidth, h: crop.clientHeight };

      const sx = Math.max(0, (-offsetX) / scale);
      const sy = Math.max(0, (-offsetY) / scale);
      const sw = Math.min(naturalW, cropW / scale);
      const sh = Math.min(naturalH, cropH / scale);

      const canvas = document.createElement('canvas');
      canvas.width = current.w;
      canvas.height = current.h;

      const ctx = canvas.getContext('2d', { alpha: false });
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      // Draw user image
      ctx.drawImage(img, sx, sy, sw, sh, 0, 0, current.w, current.h);

      // Fire TV overlays: rating badge + optional subscription text
      if (isFireTvPreset()) {
        // 1) Rating badge
        const cfgR = current.firetv.rating;
        const src = RATING_PNG[ratingValue] || "";
        if (src && ratingValue !== "none") {
          const badgeImg = ensureRatingImageLoaded(ratingValue);
          if (badgeImg && badgeImg.complete && badgeImg.naturalWidth) {
            ctx.drawImage(badgeImg, cfgR.x, cfgR.y, cfgR.w, cfgR.h);
          } else {
            // If it isn't loaded yet, attempt a synchronous fallback by loading a fresh Image
            const tmp = new Image();
            tmp.src = src;
            await new Promise(r => { tmp.onload = r; tmp.onerror = r; });
            if (tmp.naturalWidth) ctx.drawImage(tmp, cfgR.x, cfgR.y, cfgR.w, cfgR.h);
          }
        }

        // 2) Subscription text
        const enabled = toggleSubText.checked && (subTextInput.value || "").trim().length > 0;
        if (enabled) {
          const cfgT = current.firetv.subText;
          const text = subTextInput.value.trim();

          const boxW = cfgT.maxW;
          const gap = cfgT.gap;

          const badgeLeft = cfgR.x;
          const badgeTop = cfgR.y;
          const badgeH = cfgR.h;

          const boxLeft = Math.max(0, badgeLeft - gap - boxW);
          const baselineY = badgeTop + (badgeH / 2) + (cfgT.fontPx * 0.38); // optical centering

          ctx.save();
          ctx.fillStyle = "rgba(255,255,255,0.95)";
          ctx.font = `600 ${cfgT.fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
          ctx.textBaseline = "alphabetic";

          const lines = wrapText(ctx, text, boxW).slice(0, cfgT.maxLines || 2);
          const lineH = Math.round(cfgT.fontPx * 1.15);

          // If multiple lines, shift up so block stays centered around badge midline
          const blockH = (lines.length - 1) * lineH;
          let y = baselineY - (blockH / 2);

          for (const line of lines) {
            ctx.fillText(line, boxLeft, y);
            y += lineH;
          }
          ctx.restore();
        }
      }

      // Encode JPEG with size loop
      let blob = null;
      let q = 0.92;
      for (let i = 0; i < 12; i++) {
        blob = await canvasToBlob(canvas, "image/jpeg", q);
        if (!blob) break;
        if (!current.maxBytes || blob.size <= current.maxBytes) break;
        q -= 0.07;
        if (q < 0.35) break;
      }

      if (!blob) {
        setStatus("Export failed.");
        exportBtn.disabled = false;
        return;
      }

      const filename = `${originalBaseName}_${presetSlugFromHumanName()}_BG.jpg`;

      const kb = Math.round(blob.size / 1024);
      const mb = (blob.size / (1024 * 1024)).toFixed(2);
      if (current.maxBytes && blob.size > current.maxBytes) {
        setStatus(`Exported ${current.w}×${current.h}px → ${mb} MB (over limit).`);
      } else {
        setStatus(`Exported ${current.w}×${current.h}px → ${kb} KB`);
      }

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);

      exportBtn.disabled = false;
      updateQualityWarning();
    }

    exportBtn.addEventListener('click', exportAsset);

    /* ===== Init ===== */
    function init() {
      resizePreviewForPreset();
      applyPresetVisuals();
      updateQualityWarning();
      updateFireTvControlsVisibility();
    }
    init();

    window.addEventListener('resize', () => {
      if (!naturalW) return;
      computeMinScale();
      if (scale < minScale) scale = minScale;
      [offsetX, offsetY] = constrain(offsetX, offsetY, scale);
      applyTransform();
      updateBadgePreview();
      updateSubTextPreview();
    });
  </script>
</body>
</html>
